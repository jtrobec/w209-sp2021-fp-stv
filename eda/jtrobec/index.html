<!DOCTYPE html>
<html>
    <head>
        <title>MIDS W209 Spring 2021 - Final Project Exploratory Visualization - jtrobec</title>
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/d3-flame-graph@4.0.6/dist/d3-flamegraph.css">
    </head>
    <body>
        <style>
            body {
                font-family: sans-serif;
                margin: 5% 20% 5% 20%; 
            }
            #title {
                margin-bottom: 25px;
            }
            #title h1 {
                padding-bottom: 0px;
                margin-bottom: 0px;
            }
            #title h5 {
                padding-top: 5px;
                margin-top: 0px;
                margin-bottom: 0px;
            }
            .section {
                margin-top: 10px;
                margin-bottom: 10px;
            }
            .section pre {
                display: inline;
            }

            div.tooltip {	
                position: absolute;			
                text-align: center;			
                height: 28px;					
                padding: 2px;				
                font: 12px sans-serif;		
                background: lightsteelblue;	
                border: 0px;		
                border-radius: 8px;			
                pointer-events: none;			
            }

            .legendTitle {
                padding: 0;
                margin: 0;
                font-weight: bold;
            }
        </style>
        <div id='title'>
            <h1>Final Project Exploratory Visualization</h1>
            <h5>MIDS W209 Spring 2021</h5>
            <h5>Justin Trobec</h5>
        </div>
        <div id="content">
            <div class="section">
                <h4>Introduction</h4>
                Our final project is to build visualizations to generate insights from distributed trace data. Distributed tracing is a technique used to instrument
                the execution of an operation that is distributed over a group of software systems, generally referred to as services. For example, when an internet 
                application makes a request to an API endpoint, that request often is serviced by fanning out various subtasks to other services in a data center.
                Distributed tracing systems instrument the calls from service to service (also known as Remote Procedure Calls or RPCs), and gather the instrumentation
                in a central place so that the execution of the operation across the fleet can be analyzed.

                There are many distributed tracing systems in use today. We chose to use the <a href='http://zipkin.io'>Zipkin</a> system as it is open-source, actively
                developed, and relatively widely used. However, most distributed tracing systems use a similar schema to represent data, so whatever approaches to 
                visualization we develop here should be applicable to other systems.
            </div>
            <div class="section">
                <h6>Begin by inspecting the available data without visualizing the data, and write down three hypotheses.</h6>
                Zipkin and many other distributed trace systems represent traces as trees, whose nodes are referred to as spans. A single span represents and RPC call.
                Children of the span are other RPC calls generated by the parent in handling the incoming RPC request. Child spans link to their parents via the 
                <pre>parentSpanId</pre> field. See <a href="https://zipkin.io/pages/data_model.html">the Zipkin Data Model</a> page for more explanation of the data
                format.

                Our trace data was generated using a synthetic load generation tool running against a local Zipkin server. We used a script to download each generated
                trace into its own <pre>json</pre> file. In total, we produced 4666 traces. The load generation tool randomizes durations for the traces, as well as
                metadata for specific spans, including error conditions. In theory, since I generated the data, I should be able to predict it's shape, but in this
                EDA I will proceed as if this is a system I am unfamiliar with. In fact, I only briefly inspected the test topology, and made a single modification, so 
                I am not really 100% sure what to expect. Here are some hypotheses I will investigate:
                
                <ol>
                    <li>Trace tree structure is not 100% consistent for all traces with the same root.</li>
                    <li>Total duration of a trace is only loosely correlated with the total number of children.</li>
                    <li>For traces with the same root service-endpoint, differences in duration will be related to differences in child duration.</li>
                </ol>
            </div>
            <div class="section">
                <h6>Next, investigate each of your hypotheses by visualizing relevant variables...</h6> 
                <!-- (including derived variables, if that helps) in multiple ways. Look for correlations, clusters, outliers, or any other 
                patterns. See if you can find evidence for or against each hypothesis. As you explore, retain multiple sheets in your workbook that show the development 
                of your analysis. Try to find something unexpected in the data. For only one of the hypotheses, describe your exploration process, noting changes and 
                refinements you made to the visualizations as you went along, as well as what worked or didnâ€™t work during your exploration process. We expect to see at 
                least three steps in this refinement process. For the remaining two hypotheses, list each hypothesis and conclusion, provide the beginning and final visualization.-->
                To start off, I'd like to get a rough ID of how many requests come into each endpoint. To do that, I will plot the counts of the service/name pair of the root
                span of each trace:
                <div id='trace-roots-count'></div>

                So it looks like the vast majority of traces come into the <pre>frontend/cart</pre> API endpoint. I would guess that because this is the most common endpoint,
                we are likely to see the most variation in trace structure here, but that's not a given. Next, I want to look at each endpoint and figure out if the depth of
                each trace is consistent. We'll also check the distribution of span counts for traces.
                <div id='trace-roots-depth'></div>
                <div id='trace-roots-span-count'></div>

                It seems that most of the traces are consistent in terms of their depth and span count, with the exception of <pre>frontend/checkout</pre>. That answers the
                question of trace structure consistency, in that we see clearly there is some inconsistency, but I'd like to know more about the inconsistency. I'm going to
                try and show the tree structure of one of the <pre>frontend/checkout</pre> traces.

                <div id='trace-tree-structure'></div>

                There seem to be two distinct structures for this trace, based on the histograms, so I'll also find an example of one of the 2-span versions.

                <div id='trace-tree-structure-2'></div>

                This is ok, but my concern now is that a user would have to identify each possible trace form and plot them. If there are many traces, this could become really
                onerous. I think that we can do a more condensed tree format that shows the structure of all traces with a certain entry point (e.g. <pre>frontend/checkout</pre>),
                and maybe encode relative counts using either node size or color.

                <div id='trace-tree-structure-combined'></div>

                I can actually shrink this window significantly, and then show all the trace structures present in the data. Many of these are not particularly interesting, since
                they only really have one structure, but if they had more divergent structures, that would show up in the coloring of the nodes.

                <div id='trace-tree-structure-all'></div>

                As an alternative, I wanted to try applying a flamegraph, which are somewhat popular in the performance engineering industry.

                <div id='trace-tree-flamegraph'></div>
            </div>
        </div>
        <script src="https://d3js.org/d3.v6.min.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/d3-flame-graph@4.0.6/dist/d3-flamegraph.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/vega"></script>
        <script src="https://cdn.jsdelivr.net/npm/vega-lite"></script>
        <script src="https://cdn.jsdelivr.net/npm/vega-lite-api"></script>
        <script src="https://cdn.jsdelivr.net/npm/vega-tooltip"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.min.js" integrity="sha512-wNH6xsp2n8CfB91nrBtfc4sfLwYPBMjSWVUwQOp60AYYXH6i8yCwuKFZ4rgK2i6pQek/b+bSyR7b01/922IBzQ==" crossorigin="anonymous"></script>
        <script type="module">
            const getRoot = (spans) => {return spans.find(s => !(s.parentId));};
            const getSpanName = (span) => {return span.localEndpoint.serviceName + span.name;};
            const getFullyQualifiedSpanName = (span, spans) => {
                const spanShortName = getSpanName(span);
                if (span.parentId) {
                    return `${getFullyQualifiedSpanName(parentSpan, spans)}->${spanShortName}`;
                } else {
                    return spanShortName;
                }
            };
            const setSpanMetadata = (spans) => {
                let root = getRoot(spans);
                let state = {
                    spans,
                    depth: 0,
                    currentQualifiedName: ''
                };
                setSpanProps(state, root);
            };
            const setSpanProps = (state, span) => {
                span.depth = state.depth;
                span.shortName = getSpanName(span);
                span.fullyQualifiedName = `${state.currentQualifiedName}${span.shortName}`;

                let children = state.spans.filter(s => s.parentId == span.id);
                children.forEach(child => {
                    let newState = {
                        ...state,
                        depth: state.depth + 1,
                        currentQualifiedName: `${span.fullyQualifiedName}->`
                    };
                    setSpanProps(newState, child);
                });
            };

            const getFQNCounts = (traces) => {
                let counts = {}
                traces.forEach(trace => trace.forEach(s => {
                    counts[s.fullyQualifiedName] = (counts[s.fullyQualifiedName] ?? 0) + 1; 
                }))
                return counts;
            }

            const stratifiedWithCounts = (trace) => {
                const strat = traceStratify(trace);
                // iterate over all nodes and init their count
                strat.each((n) => n.count = 1);
                return strat;
            }

            const combineNodes = (a, b) => {
                const aName = getSpanName(a);
                const bName = getSpanName(b);
                if (a !== b) {
                    throw `Span names did not match, cannot combine (${aName} + ${bName})`;
                }

                const shallowA = {...a};

            }

            const combineTraceTrees = (traces) => {
                if (!traces || traces.length == 0) {
                    return undefined;
                } else {
                    const first = stratifiedWithCounts(traces[0]);
                    if (traces.length > 1) {
                        const combined = traces.slice(1).reduce((prev, cur) => {
                            const strat = stratifiedWithCounts(cur);
                            return combineNodes(prev, strat);
                        }, first);
                        return combined;
                    }
                    return first;
                }
            }

            const structureTree = (traceHierarchy, divId, boxHeight) => {
                const treeDiv = d3.select(`#${divId}`);
                const width = treeDiv.node().getBoundingClientRect().width;
                const height = boxHeight ?? (width * 0.33);
                const margin = {top: 10, left: 10, bottom: 10, right: 10};
                const inner = {width: width - margin.left - margin.right, height: height - margin.top - margin.bottom}
                const svg = treeDiv.append("svg").attr('viewBox', [0, 0, width, height]);
                
                // count the number of nodes we have on each level
                let maxDepth = 0;
                let levelIndex = 0;
                let lastDepth = 0;
                let maxLevelIndex = 0;
                traceHierarchy.each((node) => {
                    // d3-hierarchy node.each goes in depth first order, so this gives us an index
                    // for the node's global position in the level
                    if (node.depth != lastDepth) {
                        levelIndex = 0;
                        lastDepth = node.depth;
                    }
                    maxDepth = d3.max([maxDepth, node.depth]);
                    if (node.parent) {
                        levelIndex = d3.max([levelIndex, node.parent.levelIndex]);
                    }
                    node.levelIndex = levelIndex;
                    maxLevelIndex = d3.max([maxLevelIndex, levelIndex]);
                    levelIndex += 1;
                });

                const range = (start, end) => Array.from({length: (end - start)}, (v, k) => k + start);

                const scaleX = d3.scaleBand()
                                 .domain(range(0, 1+maxDepth))
                                 .range([margin.left, width-margin.right])
                                 .paddingInner(0.05);
                const scaleY = d3.scaleBand()
                                 .domain(range(0, 1+maxLevelIndex))
                                 .range([margin.top, height - margin.bottom])
                                 .paddingInner(0.05);
                const scaleColor = d3.scaleLinear()
                                     .domain([0, traceHierarchy.data.count])
                                     .range(['firebrick', 'steelblue']);

                const boxSize = d3.min([scaleX.bandwidth(), scaleY.bandwidth()]);
                const target = svg.append('g')
                                  .attr('transform', `translate(${margin.left}, ${margin.top})`);

                // Define the div for the tooltip
                const tip = d3.select("body").append("div")	
                              .attr("class", "tooltip")				
                              .style("opacity", 0);

                target.append("g")
                      .attr("class", "legendLinear")
                      .attr("transform", `translate(20,${inner.height - 50})`);

                const legendLinear = d3.legendColor()
                                       .title('Node Counts')
                                       .shapeWidth(30)
                                       .cells(5)
                                       .orient('horizontal')
                                       .scale(scaleColor);

                target.select(".legendLinear")
                      .call(legendLinear);

                target.append("g")
                    .attr("fill", "none")
                    .attr("stroke", "#555")
                    .attr("stroke-opacity", 0.4)
                    .attr("stroke-width", 1.5)
                    .selectAll('path')
                    .data(traceHierarchy.links())
                    .join('path')
                    .attr("d", d3.linkHorizontal()
                        .x(n => scaleX(n.depth) + boxSize/2)
                        .y(n => scaleY(n.levelIndex) + boxSize/2));

                target.append('g')
                    .selectAll('rect')
                    .data(traceHierarchy)
                    .join('rect')
                    .attr('x', n => scaleX(n.depth))
                    .attr('y', n => scaleY(n.levelIndex))
                    .attr('width', boxSize)
                    .attr('height', boxSize)
                    .attr('rx', 10)
                    .attr('ry', 10)
                    .attr('fill', n => scaleColor(n.data.count))
                    .on("mouseover", (e, n) => {		
                        tip.transition()		
                           .duration(200)		
                           .style("opacity", .9);		
                        tip.html(`<strong>${n.data.shortName}</strong><br/>Count: ${n.data.count}`)	
                           .style("left", (e.pageX) + "px")		
                           .style("top", (e.pageY - 28) + "px");	
                        })					
                    .on("mouseout", d => {		
                        tip.transition()		
                           .duration(500)		
                           .style("opacity", 0);	
                    });;

            }

            const drawTraceTree = (traceTree, divId, boxHeight) => {
                const treeDiv = d3.select(`#${divId}`);
                const width = treeDiv.node().getBoundingClientRect().width;
                const height = boxHeight ?? (width * 0.33);
                const margin = {top: 10, left: 100, bottom: 10, right: 10};
                const iheight = height - margin.top - margin.bottom;
                const svg = treeDiv.append("svg").attr('viewBox', [0, 0, width, height]);
                const dy = width/(traceTree.height + 1);
                const dx = margin.left;
                const root = d3.tree().nodeSize([dx, dy])(traceTree);
                let x0 = Infinity;
                let x1 = -x0;
                root.each(d => {
                    if (d.x > x1) x1 = d.x;
                    if (d.x < x0) x0 = d.x;
                });

                const g = svg.append("g")
                    .attr("font-family", "sans-serif")
                    .attr("font-size", 10)
                    .attr("transform", `translate(${dx},${margin.top + (iheight/2)})`);
                
                const link = g.append("g")
                .attr("fill", "none")
                .attr("stroke", "#555")
                .attr("stroke-opacity", 0.4)
                .attr("stroke-width", 1.5)
                .selectAll("path")
                .data(root.links())
                .join("path")
                    .attr("d", d3.linkHorizontal()
                        .x(d => d.y)
                        .y(d => d.x));

                const node = g.append("g")
                    .attr("stroke-linejoin", "round")
                    .attr("stroke-width", 3)
                .selectAll("g")
                .data(root.descendants())
                .join("g")
                    .attr("transform", d => `translate(${d.y},${d.x})`);

                node.append("circle")
                    .attr("fill", d => d.children ? "#555" : "#999")
                    .attr("r", 2.5);

                node.append("text")
                    .attr("dy", "0.31em")
                    .attr("x", d => d.children ? -6 : 6)
                    .attr("text-anchor", d => d.children ? "end" : "start")
                    .text(d => getSpanName(d.data))
                .clone(true).lower()
                    .attr("stroke", "white");
            }

            const options = {
                config: {
                    // Vega-Lite default configuration
                },
                init: (view) => {
                    // initialize tooltip handler
                    view.tooltip(new vegaTooltip.Handler().call);
                },
                view: {
                    // view constructor options
                    // remove the loader if you don't want to default to vega-datasets!
                    loader: vega.loader({
                        baseURL: "https://cdn.jsdelivr.net/npm/vega-datasets@2/",
                    }),
                    renderer: "canvas",
                },
            };

            // register vega and vega-lite with the API
            vl.register(vega, vegaLite, options);

            d3.json("./trace-files.json").then((traceList) => {
                let promises = traceList.slice(0, 500).map(f => d3.json(`/data/synthetic/20210302-hipster-shop/${f}`)
                                                    .catch(function(error){
                                                        console.log(error);
                                                        return [];
                                                    }));
                let traces = Promise.all(promises).then(traces => {
                    // some of the traces in the collection are bogus
                    let goodTraces = traces.filter(x => x.length > 0);
                    let traceRoots = d3.group(goodTraces.map(getRoot), getSpanName);
                    let rootCounts = Array.from(traceRoots.entries(), x => ({name: x[0], count: x[1].length}));

                    vl.markBar({ tooltip: true })
                        .data(rootCounts)
                        .encode(
                            vl.x().fieldQ("count"),
                            vl.y().fieldN("name"),
                            vl.tooltip([vl.fieldQ("count"), vl.fieldN("name")])
                        )
                        .render()
                        .then(viewElement => {
                            // render returns a promise to a DOM element containing the chart
                            // viewElement.value contains the Vega View object instance
                            document.getElementById('trace-roots-count').appendChild(viewElement);
                        });

                    // now we'll set the depth and FQN of the span as a property of each span, in case we want to use it later
                    goodTraces.forEach(t => setSpanMetadata(t));
                    
                    let rootDepths = goodTraces.map(spans => ({name: getSpanName(getRoot(spans)), maxDepth: d3.max(spans, x => x.depth)}));
                    let rootSpanCounts = goodTraces.map(spans => ({name: getSpanName(getRoot(spans)), spanCount: spans.length}))

                    vl.markBar({ tooltip: true })
                        .data(rootDepths)
                        .encode(
                            vl.x().fieldQ("maxDepth").bin(true),
                            vl.y().count(),
                            vl.column().fieldN("name"),
                            vl.tooltip([vl.fieldQ("maxDepth"), vl.fieldN("name")])
                        )
                        .render()
                        .then(viewElement => {
                            // render returns a promise to a DOM element containing the chart
                            // viewElement.value contains the Vega View object instance
                            document.getElementById('trace-roots-depth').appendChild(viewElement);
                        });

                    vl.markBar({ tooltip: true })
                        .data(rootSpanCounts)
                        .encode(
                            vl.x().fieldQ("spanCount").bin(true),
                            vl.y().count(),
                            vl.column().fieldN("name"),
                            vl.tooltip([vl.fieldQ("spanCount"), vl.fieldN("name")])
                        )
                        .render()
                        .then(viewElement => {
                            // render returns a promise to a DOM element containing the chart
                            // viewElement.value contains the Vega View object instance
                            document.getElementById('trace-roots-span-count').appendChild(viewElement);
                        });

                    
                    const traceStratify = d3.stratify()
                                            .id(d => d.id)
                                            .parentId(d => d.parentId);

                    const countStratify = d3.stratify()
                                            .id(d => d.fullyQualifiedName)
                                            .parentId(d => d.parentFullyQualifiedName);

                    const checkoutTraces = goodTraces.filter(t => getSpanName(getRoot(t)) === 'frontend/checkout');
                    const exampleCheckoutTrace = checkoutTraces[3];
                    const stratifiedExample = traceStratify(exampleCheckoutTrace);
                    drawTraceTree(stratifiedExample, 'trace-tree-structure');

                    const exampleCheckoutTrace2 = checkoutTraces.find(x => x.length == 2);
                    const stratified2 = traceStratify(exampleCheckoutTrace2);
                    drawTraceTree(stratified2, 'trace-tree-structure-2', 100);

                    const countForest = getFQNCounts(checkoutTraces);
                    const traceStructure = countStratify(Object.entries(countForest).map(([k, v]) => {
                        const lastArrow = k.lastIndexOf('->');
                        if (lastArrow >= 0) {
                            return {
                                fullyQualifiedName: k,
                                shortName: k.slice(lastArrow + 2),
                                parentFullyQualifiedName: k.slice(0, lastArrow),
                                count: v
                            }
                        } else {
                            return {
                                fullyQualifiedName: k,
                                shortName: k,
                                count: v
                            };
                        }
                    }));

                    structureTree(traceStructure, 'trace-tree-structure-combined', 250);

                    const checkoutTraceCount = checkoutTraces.length;
                    traceStructure.each(x => {
                        x.name = x.data.shortName;
                        if (x.parent) {
                            x.value = (x.parent.value / x.parent.children.length) * (x.data.count / x.parent.data.count);
                        } else {
                            x.value = x.data.count;
                        }
                    });
                    
                    const flameDiv = d3.select("#trace-tree-flamegraph");
                    const flameWidth = flameDiv.node().getBoundingClientRect().width;
                    const chart = flamegraph().width(flameWidth);
                    flameDiv
                      .datum(traceStructure)
                      .call(chart);
                });
            });
        </script>
        <!--

            columnions tried: 20 points
    Experimentation with a variety of chart types: 15 points
    Refinement within individual chart types: 15 points
    Applying information gained in one visualization to enhance another: 10 points
    Clear and reasonable hypotheses: 10 points
    Reasonable conclusion for each hypothesis: 10 points
    Describing the work in enough detail to follow it: 10 points
    Clear and readable writing: 10 points

        -->
    </body>
</html>