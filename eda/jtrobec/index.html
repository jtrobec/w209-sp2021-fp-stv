<!DOCTYPE html>
<html>
    <head>
        <title>MIDS W209 Spring 2021 - Final Project Exploratory Visualization - jtrobec</title>
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/d3-flame-graph@4.0.6/dist/d3-flamegraph.css">
    </head>
    <body>
        <style>
            body {
                font-family: sans-serif;
                margin: 5% 20% 5% 20%; 
            }
            #title {
                margin-bottom: 25px;
            }
            #title h1 {
                padding-bottom: 0px;
                margin-bottom: 0px;
            }
            #title h5 {
                padding-top: 5px;
                margin-top: 0px;
                margin-bottom: 0px;
            }
            .section {
                margin-top: 10px;
                margin-bottom: 10px;
            }
            .section pre {
                display: inline;
            }

            div.tooltip {	
                position: absolute;			
                text-align: center;			
                height: 28px;					
                padding: 2px;				
                font: 12px sans-serif;		
                background: lightsteelblue;	
                border: 0px;		
                border-radius: 8px;			
                pointer-events: none;			
            }

            .legendTitle {
                padding: 0;
                margin: 0;
                font-weight: bold;
                font-size: 0.8em;
            }

            .legendLinear .label {
                font-size: 0.6em;
            }

            div.traceRow{
                display: flex;
            }

            div.traceStructDiv {
                flex: 49%;
            }
            #h2 div {
                margin-bottom: 50px;
            }
        </style>
        <script src="https://d3js.org/d3.v6.min.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/d3-flame-graph@4.0.6/dist/d3-flamegraph.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/vega"></script>
        <script src="https://cdn.jsdelivr.net/npm/vega-lite"></script>
        <script src="https://cdn.jsdelivr.net/npm/vega-lite-api"></script>
        <script src="https://cdn.jsdelivr.net/npm/vega-tooltip"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.min.js" integrity="sha512-wNH6xsp2n8CfB91nrBtfc4sfLwYPBMjSWVUwQOp60AYYXH6i8yCwuKFZ4rgK2i6pQek/b+bSyR7b01/922IBzQ==" crossorigin="anonymous"></script>

        <div id='title'>
            <h1>Final Project Exploratory Visualization</h1>
            <h5>MIDS W209 Spring 2021</h5>
            <h5>Justin Trobec</h5>
        </div>
        <div id="content">
            <div class="section">
                <h4>Introduction</h4>
                Our final project is to build visualizations to generate insights from distributed trace data. Distributed tracing is a technique used to instrument
                the execution of an operation that is distributed over a group of software systems, generally referred to as services. For example, when an internet 
                application makes a request to an API endpoint, that request often is serviced by fanning out various subtasks to other services in a data center.
                Distributed tracing systems instrument the calls from service to service (also known as Remote Procedure Calls or RPCs), and gather the instrumentation
                in a central place so that the execution of the operation across the fleet can be analyzed.

                There are many distributed tracing systems in use today. We chose to use the <a href='http://zipkin.io'>Zipkin</a> system as it is open-source, actively
                developed, and relatively widely used. However, most distributed tracing systems use a similar schema to represent data, so whatever approaches to 
                visualization we develop here should be applicable to other systems.
            </div>
            <div class="section">
                <h6>Begin by inspecting the available data without visualizing the data, and write down three hypotheses.</h6>
                Zipkin and many other distributed trace systems represent traces as trees, whose nodes are referred to as spans. A single span represents and RPC call.
                Children of the span are other RPC calls generated by the parent in handling the incoming RPC request. Child spans link to their parents via the 
                <pre>parentSpanId</pre> field. See <a href="https://zipkin.io/pages/data_model.html">the Zipkin Data Model</a> page for more explanation of the data
                format.

                Our trace data was generated using a synthetic load generation tool running against a local Zipkin server. We used a script to download each generated
                trace into its own <pre>json</pre> file. In total, we produced 4666 traces. The load generation tool randomizes durations for the traces, as well as
                metadata for specific spans, including error conditions. In theory, since I generated the data, I should be able to predict it's shape, but in this
                EDA I will proceed as if this is a system I am unfamiliar with. In fact, I only briefly inspected the test topology, and made a single modification, so 
                I am not really 100% sure what to expect. Here are some hypotheses I will investigate:
                
                <ol>
                    <li>Trace tree structure is not 100% consistent for all traces with the same root.</li>
                    <li>Total duration of a trace is only loosely correlated with the total number of children.</li>
                    <li>For traces with the same root service-endpoint, differences in duration will be related to differences in child duration.</li>
                </ol>
            </div>
            <div class="section">
                <h4>H1: Trace tree structure is not 100% consistent for all traces with the same root.</h4>
                <h6>Next, investigate each of your hypotheses by visualizing relevant variables...</h6> 
                <!-- (including derived variables, if that helps) in multiple ways. Look for correlations, clusters, outliers, or any other 
                patterns. See if you can find evidence for or against each hypothesis. As you explore, retain multiple sheets in your workbook that show the development 
                of your analysis. Try to find something unexpected in the data. For only one of the hypotheses, describe your exploration process, noting changes and 
                refinements you made to the visualizations as you went along, as well as what worked or didnâ€™t work during your exploration process. We expect to see at 
                least three steps in this refinement process. For the remaining two hypotheses, list each hypothesis and conclusion, provide the beginning and final visualization.-->
                To start off, I'd like to get a rough ID of how many requests come into each endpoint. To do that, I will plot the counts of the service/name pair of the root
                span of each trace:
                <div id='trace-roots-count'></div>

                So it looks like the vast majority of traces come into the <pre>frontend/cart</pre> API endpoint. I would guess that because this is the most common endpoint,
                we are likely to see the most variation in trace structure here, but that's not a given. Next, I want to look at each endpoint and figure out if the depth of
                each trace is consistent. We'll also check the distribution of span counts for traces.
                <div id='trace-roots-depth'></div>
                <div id='trace-roots-span-count'></div>

                It seems that most of the traces are consistent in terms of their depth and span count, with the exception of <pre>frontend/checkout</pre>. That answers the
                question of trace structure consistency, in that we see clearly there is some inconsistency, but I'd like to know more about the inconsistency. I'm going to
                try and show the tree structure of one of the <pre>frontend/checkout</pre> traces.

                <div id='trace-tree-structure'></div>

                There seem to be two distinct structures for this trace, based on the histograms, so I'll also find an example of one of the 2-span versions.

                <div id='trace-tree-structure-2'></div>

                This is ok, but my concern now is that a user would have to identify each possible trace form and plot them. If there are many traces, this could become really
                onerous. I think that we can do a more condensed tree format that shows the structure of all traces with a certain entry point (e.g. <pre>frontend/checkout</pre>),
                and maybe encode relative counts using either node size or color.

                <div id='trace-tree-structure-combined'></div>
                <p>
                When I was iterating on this visualization, I would slice the number of traces that I used down to 500 instead of the full 4.5k. This allowed me to iterate more
                quickly since it took much less time to load. After I finished this visualization, I tested with the full set, and found this surprising insight: there are actually
                three distinct trace structures for this particular API endpoint. Based on the histograms I used earlier to see depth and count of spans, I thought there were only
                two. But it turns out that one of the deepest nodes is sometimes missing. I didn't see this in the depth count because similar traces are just as deep, and I
                couldn't see it in the span count histogram because the binning happened to put traces with 8 and 9 spans together. I think this is a pretty good demonstration of
                why this visualization is a more useful way to compare the structure of the trees than plotting summary statistics.
                </p><p>
                I can actually shrink this window significantly, and then show all the trace structures present in the data. Many of these are not particularly interesting, since
                they only really have one structure, but if they had more divergent structures, that would show up in the coloring of the nodes. The nice thing is, because each
                endpoint has all their traces represented in a single tree, I can get a sense of all the structures and relative counts at once.
                </p>
                <div id='trace-tree-structure-all'></div>
                <p>
                As an alternative, I wanted to try applying a flamegraph, which are somewhat popular in the performance engineering industry. The information is essentially the
                same; the width of a bar represents the relative percentage of parent calls in which the child appears, divided by the number of children the parent has. This is a
                complicated thing to articulate with words, but I believe the visual representation ends up being fairly intuitive, especially if you've seen the trace structure
                graph first. The flame graph allows drilling in on a specific child, so if you click on a node, it expands to fill-up 100% of the width, and its children expand so
                you can get a closer look at their relative occurrences.
                </p>
                <div id='trace-tree-flamegraph'></div>
                <p>
                Ultimately, the hypothesis that trace structures are not 100% consistent within the same endpoint is easily validated by either view. It's good to note as well that
                the histograms I tried actually ended up misleading me about the shape of the traces, which underscores the importance of including the hierarchy as part of the
                visualization.
                </p>
            </div>
            <div class="section" id="h2">
                <h4>H2: Total duration of a trace is only loosely correlated with the total number of children.</h4>
                <div id='trace-durations'></div>
                <div id='trace-durations-by-name'></div>
                <div id='trace-duration-to-count'></div>
                <p>
                It's a little tough to draw a conclusion here. It seems pretty clear that the traces with more spans tend to be longer, however trace span counts are very segmented
                by trace type. Within trace types, there is a spread of durations, even though in most cases we have the same number of spans. In this case, I feel like the visualization
                mostly contradicts the hypothesis...it seems like there is a reasonably strong correlation between span count and trace duration.
                </p>
            </div>
            <div class="section" id="h3">
                <h4>H3: For traces with the same root service-endpoint, differences in duration will be related to differences in child duration.</h4>
                <p>
                For this particular hypothesis I should explain why this might not be a given. It's possible in these traces that a lot of work is executed in parallel. If that's the
                case, then the durations of the child spans may not directly impact the duration of the trace, so it's not a guarantee that we would have a tight relationship between
                parent duration and child span duration.
                </p>
                <div id="trace-duration-to-sum-of-span-duration-regression"></div>
                <p>
                In this case the relationship is pretty clear. Adding the regression line shows that the slope is just shy of 1:1, so we have a very strong correlation between the
                duration of the trace and the total duration of child spans. This supports our hypothesis that the duration of child spans is a good predictor of the total trace duration.
                </p>
            </div>
        </div>
        <script type="module">
            const getRoot = (spans) => {return spans.find(s => !(s.parentId));};
            const getSpanName = (span) => {return span.localEndpoint.serviceName + span.name;};
            const getFullyQualifiedSpanName = (span, spans) => {
                const spanShortName = getSpanName(span);
                if (span.parentId) {
                    return `${getFullyQualifiedSpanName(parentSpan, spans)}->${spanShortName}`;
                } else {
                    return spanShortName;
                }
            };
            const setSpanMetadata = (spans) => {
                let root = getRoot(spans);
                let state = {
                    spans,
                    depth: 0,
                    currentQualifiedName: ''
                };
                setSpanProps(state, root);
            };
            const setSpanProps = (state, span) => {
                span.depth = state.depth;
                span.shortName = getSpanName(span);
                span.fullyQualifiedName = `${state.currentQualifiedName}${span.shortName}`;

                let children = state.spans.filter(s => s.parentId == span.id);
                children.forEach(child => {
                    let newState = {
                        ...state,
                        depth: state.depth + 1,
                        currentQualifiedName: `${span.fullyQualifiedName}->`
                    };
                    setSpanProps(newState, child);
                });
            };

            const getFQNCounts = (traces) => {
                let counts = {}
                traces.forEach(trace => trace.forEach(s => {
                    counts[s.fullyQualifiedName] = (counts[s.fullyQualifiedName] ?? 0) + 1; 
                }))
                return counts;
            }

            const fqnCountsToParentChild = (countForest) => Object.entries(countForest).map(([k, v]) => {
                const lastArrow = k.lastIndexOf('->');
                if (lastArrow >= 0) {
                    return {
                        fullyQualifiedName: k,
                        shortName: k.slice(lastArrow + 2),
                        parentFullyQualifiedName: k.slice(0, lastArrow),
                        count: v
                    }
                } else {
                    return {
                        fullyQualifiedName: k,
                        shortName: k,
                        count: v
                    };
                }
            });

            const stratifiedWithCounts = (trace) => {
                const strat = traceStratify(trace);
                // iterate over all nodes and init their count
                strat.each((n) => n.count = 1);
                return strat;
            }

            const combineNodes = (a, b) => {
                const aName = getSpanName(a);
                const bName = getSpanName(b);
                if (a !== b) {
                    throw `Span names did not match, cannot combine (${aName} + ${bName})`;
                }

                const shallowA = {...a};

            }

            const combineTraceTrees = (traces) => {
                if (!traces || traces.length == 0) {
                    return undefined;
                } else {
                    const first = stratifiedWithCounts(traces[0]);
                    if (traces.length > 1) {
                        const combined = traces.slice(1).reduce((prev, cur) => {
                            const strat = stratifiedWithCounts(cur);
                            return combineNodes(prev, strat);
                        }, first);
                        return combined;
                    }
                    return first;
                }
            }

            const structureTree = (traceHierarchy, treeDiv, boxHeight) => {
                const width = treeDiv.node().getBoundingClientRect().width;
                const height = boxHeight ?? (width * 0.33);
                const margin = {top: 10, left: 10, bottom: 60, right: 10};
                const inner = {width: width - margin.left - margin.right, height: height - margin.top - margin.bottom}
                const svg = treeDiv.append("svg").attr('viewBox', [0, 0, width, height]);
                
                // count the number of nodes we have on each level
                let maxDepth = 0;
                let levelIndex = 0;
                let lastDepth = 0;
                let maxLevelIndex = 0;
                traceHierarchy.each((node) => {
                    // d3-hierarchy node.each goes in depth first order, so this gives us an index
                    // for the node's global position in the level
                    if (node.depth != lastDepth) {
                        levelIndex = 0;
                        lastDepth = node.depth;
                    }
                    maxDepth = d3.max([maxDepth, node.depth]);
                    if (node.parent) {
                        levelIndex = d3.max([levelIndex, node.parent.levelIndex]);
                    }
                    node.levelIndex = levelIndex;
                    maxLevelIndex = d3.max([maxLevelIndex, levelIndex]);
                    levelIndex += 1;
                });

                const range = (start, end) => Array.from({length: (end - start)}, (v, k) => k + start);

                const scaleX = d3.scaleBand()
                                 .domain(range(0, 1+maxDepth))
                                 .range([margin.left, width-margin.right])
                                 .paddingInner(0.05);
                const scaleY = d3.scaleBand()
                                 .domain(range(0, 1+maxLevelIndex))
                                 .range([margin.top, height - margin.bottom])
                                 .paddingInner(0.05);
                const scaleColor = d3.scaleSequential(d3.interpolateCividis)
                                     .domain([0, traceHierarchy.data.count]);

                const boxSize = d3.min([30, scaleX.bandwidth(), scaleY.bandwidth()]);
                const target = svg.append('g')
                                  .attr('transform', `translate(${margin.left}, ${margin.top})`);

                // Define the div for the tooltip
                const tip = d3.select("body").append("div")	
                              .attr("class", "tooltip")				
                              .style("opacity", 0);

                target.append("g")
                      .attr("class", "legendLinear")
                      .attr("transform", `translate(20,${height - margin.bottom})`);

                const legendLinear = d3.legendColor()
                                       .title('Node Counts')
                                       .shapeWidth(30)
                                       .cells(5)
                                       .orient('horizontal')
                                       .scale(scaleColor);

                target.select(".legendLinear")
                      .call(legendLinear);

                target.append("g")
                    .attr("fill", "none")
                    .attr("stroke", "#555")
                    .attr("stroke-opacity", 0.4)
                    .attr("stroke-width", 1.5)
                    .selectAll('path')
                    .data(traceHierarchy.links())
                    .join('path')
                    .attr("d", d3.linkHorizontal()
                        .x(n => scaleX(n.depth) + boxSize/2)
                        .y(n => scaleY(n.levelIndex) + boxSize/2));

                target.append('g')
                    .selectAll('rect')
                    .data(traceHierarchy)
                    .join('rect')
                    .attr('x', n => scaleX(n.depth))
                    .attr('y', n => scaleY(n.levelIndex))
                    .attr('width', boxSize)
                    .attr('height', boxSize)
                    .attr('rx', 5)
                    .attr('ry', 5)
                    .attr('fill', n => scaleColor(n.data.count))
                    .on("mouseover", (e, n) => {		
                        tip.transition()		
                           .duration(200)		
                           .style("opacity", .9);		
                        tip.html(`<strong>${n.data.shortName}</strong><br/>Count: ${n.data.count}`)	
                           .style("left", (e.pageX) + "px")		
                           .style("top", (e.pageY - 28) + "px");	
                        })					
                    .on("mouseout", d => {		
                        tip.transition()		
                           .duration(500)		
                           .style("opacity", 0);	
                    });;

            }

            const drawTraceTree = (traceTree, divId, boxHeight) => {
                const treeDiv = d3.select(`#${divId}`);
                const width = treeDiv.node().getBoundingClientRect().width;
                const height = boxHeight ?? (width * 0.33);
                const margin = {top: 10, left: 100, bottom: 10, right: 10};
                const iheight = height - margin.top - margin.bottom;
                const svg = treeDiv.append("svg").attr('viewBox', [0, 0, width, height]);
                const dy = width/(traceTree.height + 1);
                const dx = margin.left;
                const root = d3.tree().nodeSize([dx, dy])(traceTree);
                let x0 = Infinity;
                let x1 = -x0;
                root.each(d => {
                    if (d.x > x1) x1 = d.x;
                    if (d.x < x0) x0 = d.x;
                });

                const g = svg.append("g")
                    .attr("font-family", "sans-serif")
                    .attr("font-size", 10)
                    .attr("transform", `translate(${dx},${margin.top + (iheight/2)})`);
                
                const link = g.append("g")
                .attr("fill", "none")
                .attr("stroke", "#555")
                .attr("stroke-opacity", 0.4)
                .attr("stroke-width", 1.5)
                .selectAll("path")
                .data(root.links())
                .join("path")
                    .attr("d", d3.linkHorizontal()
                        .x(d => d.y)
                        .y(d => d.x));

                const node = g.append("g")
                    .attr("stroke-linejoin", "round")
                    .attr("stroke-width", 3)
                .selectAll("g")
                .data(root.descendants())
                .join("g")
                    .attr("transform", d => `translate(${d.y},${d.x})`);

                node.append("circle")
                    .attr("fill", d => d.children ? "#555" : "#999")
                    .attr("r", 2.5);

                node.append("text")
                    .attr("dy", "0.31em")
                    .attr("x", d => d.children ? -6 : 6)
                    .attr("text-anchor", d => d.children ? "end" : "start")
                    .text(d => getSpanName(d.data))
                .clone(true).lower()
                    .attr("stroke", "white");
            }

            const options = {
                config: {
                    // Vega-Lite default configuration
                },
                init: (view) => {
                    // initialize tooltip handler
                    view.tooltip(new vegaTooltip.Handler().call);
                },
                view: {
                    // view constructor options
                    // remove the loader if you don't want to default to vega-datasets!
                    loader: vega.loader({
                        baseURL: "https://cdn.jsdelivr.net/npm/vega-datasets@2/",
                    }),
                    renderer: "canvas",
                },
            };

            // register vega and vega-lite with the API
            vl.register(vega, vegaLite, options);

            d3.json("./trace-files.json").then((traceList) => {
                let promises = traceList.map(f => d3.json(`/data/synthetic/20210302-hipster-shop/${f}`)
                //let promises = traceList.slice(0, 500).map(f => d3.json(`/data/synthetic/20210302-hipster-shop/${f}`)
                                                    .catch(function(error){
                                                        console.log(error);
                                                        return [];
                                                    }));
                let traces = Promise.all(promises).then(traces => {
                    // some of the traces in the collection are bogus
                    let goodTraces = traces.filter(x => x.length > 0);
                    let traceRoots = d3.group(goodTraces.map(getRoot), getSpanName);
                    let rootCounts = Array.from(traceRoots.entries(), x => ({name: x[0], count: x[1].length}));

                    vl.markBar({ tooltip: true })
                        .data(rootCounts)
                        .encode(
                            vl.x().fieldQ("count"),
                            vl.y().fieldN("name"),
                            vl.tooltip([vl.fieldQ("count"), vl.fieldN("name")])
                        )
                        .render()
                        .then(viewElement => {
                            // render returns a promise to a DOM element containing the chart
                            // viewElement.value contains the Vega View object instance
                            document.getElementById('trace-roots-count').appendChild(viewElement);
                        });

                    // now we'll set the depth and FQN of the span as a property of each span, in case we want to use it later
                    goodTraces.forEach(t => setSpanMetadata(t));
                    
                    let rootDepths = goodTraces.map(spans => ({name: getSpanName(getRoot(spans)), maxDepth: d3.max(spans, x => x.depth)}));
                    let rootSpanCounts = goodTraces.map(spans => ({name: getSpanName(getRoot(spans)), spanCount: spans.length}))

                    vl.markBar({ tooltip: true })
                        .data(rootDepths)
                        .encode(
                            vl.x().fieldQ("maxDepth").bin(true),
                            vl.y().count(),
                            vl.column().fieldN("name"),
                            vl.tooltip([vl.fieldQ("maxDepth"), vl.fieldN("name")])
                        )
                        .render()
                        .then(viewElement => {
                            // render returns a promise to a DOM element containing the chart
                            // viewElement.value contains the Vega View object instance
                            document.getElementById('trace-roots-depth').appendChild(viewElement);
                        });

                    vl.markBar({ tooltip: true })
                        .data(rootSpanCounts)
                        .encode(
                            vl.x().fieldQ("spanCount").bin(true),
                            vl.y().count(),
                            vl.column().fieldN("name"),
                            vl.tooltip([vl.fieldQ("spanCount"), vl.fieldN("name")])
                        )
                        .render()
                        .then(viewElement => {
                            // render returns a promise to a DOM element containing the chart
                            // viewElement.value contains the Vega View object instance
                            document.getElementById('trace-roots-span-count').appendChild(viewElement);
                        });

                    
                    const traceStratify = d3.stratify()
                                            .id(d => d.id)
                                            .parentId(d => d.parentId);

                    const countStratify = d3.stratify()
                                            .id(d => d.fullyQualifiedName)
                                            .parentId(d => d.parentFullyQualifiedName);

                    const checkoutTraces = goodTraces.filter(t => getSpanName(getRoot(t)) === 'frontend/checkout');
                    const exampleCheckoutTrace = checkoutTraces[3];
                    const stratifiedExample = traceStratify(exampleCheckoutTrace);
                    drawTraceTree(stratifiedExample, 'trace-tree-structure');

                    const exampleCheckoutTrace2 = checkoutTraces.find(x => x.length == 2);
                    const stratified2 = traceStratify(exampleCheckoutTrace2);
                    drawTraceTree(stratified2, 'trace-tree-structure-2', 100);

                    const countForest = getFQNCounts(checkoutTraces);
                    const traceStructure = countStratify(fqnCountsToParentChild(countForest));
                    structureTree(traceStructure, d3.select('#trace-tree-structure-combined'), 250);

                    const allTraceDiv = d3.select('#trace-tree-structure-all');
                    const traceGroups = d3.group(goodTraces, t => getSpanName(getRoot(t)));
                    let currentRow = allTraceDiv.append('div').attr('class', 'traceRow');
                    traceGroups.forEach((traces) => {
                        const tcounts = getFQNCounts(traces);
                        const tstruct = countStratify(fqnCountsToParentChild(tcounts));
                        const newDiv = currentRow.append('div')
                                                 .attr('class', 'traceStructDiv');
                        structureTree(tstruct, newDiv, 200);
                        if (currentRow.node().children.length > 1) {
                            currentRow = allTraceDiv.append('div').attr('class', 'traceRow');
                        }
                    })

                    // plot a flamegraph -- need to do some math to make it look right
                    const checkoutTraceCount = checkoutTraces.length;
                    traceStructure.each(x => {
                        x.name = x.data.shortName;
                        if (x.parent) {
                            x.value = (x.parent.value / x.parent.children.length) * (x.data.count / x.parent.data.count);
                        } else {
                            x.value = x.data.count;
                        }
                    });

                    const flameDiv = d3.select("#trace-tree-flamegraph");
                    const flameWidth = flameDiv.node().getBoundingClientRect().width;
                    const chart = flamegraph().width(flameWidth);
                    flameDiv
                      .datum(traceStructure)
                      .call(chart);

                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // H2 code - trace duration to span count
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    const traceDurations = goodTraces.map(t => {
                        const root = getRoot(t);
                        const notRoot = t.filter(x => x.id != root.id)
                        return {
                            name: getSpanName(root),
                            duration: root.duration,
                            spanDurationSum: d3.sum(notRoot, x => x.duration),
                            spanDurationMean: d3.mean(notRoot, x => x.duration),
                            spanCount: t.length
                        }
                    });
                    vl.markBar({ tooltip: true })
                        .data(traceDurations)
                        .encode(
                            vl.x().fieldQ("duration").bin(true),
                            vl.y().count(),
                            vl.tooltip([vl.fieldQ("duration"), vl.fieldN("name")])
                        )
                        .render()
                        .then(viewElement => {
                            // render returns a promise to a DOM element containing the chart
                            // viewElement.value contains the Vega View object instance
                            document.getElementById('trace-durations').appendChild(viewElement);
                        });
                    vl.markBar({ tooltip: true })
                        .data(traceDurations)
                        .encode(
                            vl.x().fieldQ("duration").bin(true),
                            vl.y().count(),
                            vl.column().fieldN("name"),
                            vl.tooltip([vl.fieldQ("duration"), vl.fieldN("name")])
                        )
                        .render()
                        .then(viewElement => {
                            // render returns a promise to a DOM element containing the chart
                            // viewElement.value contains the Vega View object instance
                            document.getElementById('trace-durations-by-name').appendChild(viewElement);
                        });
                    
                    vl.markPoint({ tooltip: true })
                        .title('Trace Duration by Count of Spans')
                        .width(600)
                        .height(600)
                        .data(traceDurations)
                        .encode(
                            vl.y().fieldQ("duration"),
                            vl.x().fieldQ("spanCount"),
                            vl.color().fieldN("name"),
                            vl.tooltip([vl.fieldQ("duration"), vl.fieldQ("spanCount"), vl.fieldN("name")])
                        )
                        .render()
                        .then(viewElement => {
                            document.getElementById('trace-duration-to-count').appendChild(viewElement);
                        });

                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // H3 code - trace duration to span duration
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    const scatter = vl.markPoint({ tooltip: true })
                        .title('Trace Duration by Sum of Child Span Duration')
                        .width(300)
                        .height(300)
                        .data(traceDurations)
                        .encode(
                            vl.y().fieldQ("duration"),
                            vl.x().fieldQ("spanDurationSum"),
                            vl.color().fieldN("name"),
                            vl.tooltip([vl.fieldQ("duration"), vl.fieldQ("spanDurationSum"), vl.fieldN("name")])
                        )
                    
                    const regression = vl.markLine()
                        .width(300)
                        .height(300)
                        .data(traceDurations)
                        .transform(
                            vl.regression('duration').on('spanDurationSum')
                        )
                        .encode(
                            vl.y().fieldQ("duration"),
                            vl.x().fieldQ("spanDurationSum"),
                        );

                    const layer = vl.layer(scatter, regression);
                    vl.hconcat(scatter, layer.title("with Regression Line")).render()
                        .then(viewElement => {
                            document.getElementById('trace-duration-to-sum-of-span-duration-regression').appendChild(viewElement);
                        });
                });
            });
        </script>
    </body>
</html>